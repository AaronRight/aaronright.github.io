<html>
    <head>
        <style>
        .block {
          position: absolute;
          border: 1px solid black;
          height: 100px;
          width: 100px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
        }
        </style>
        <script src="https://unpkg.com/vue"></script>
    </head>
    <body> 
      <div id="app">
          <button @click="click">Click</button>
          <flowchart></flowchart>
          <flowchart-editor></flowchart-editor>
          <node></node>
          <node></node>
          <edge></edge>
      </div>
    </body>
</html>

<script>
  const _data = {
    draggableElementId: null, // if this is present, only a specific area of the draggable will respond to dragging (eg header bar).
    down: false,
    height: 0,
    width: 0,
    initialX: 0,
    initialY: 0,
    constraintToWindow: false,
    cursorPreviousX: 0,
    cursorPreviousY: 0,
    draggerOffsetLeft: 0,
    draggerOffsetTop: 0,
    overlay: null,
    draggableEl: null,
    initialZIndex: undefined
}

function createOverlay (e, el, _data) {
  const overlay = document.createElement('div')
  overlay.setAttribute('style', `
    width: 100vw; 
    height: 100vh; 
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10000;
  `)
  overlay.addEventListener('mouseup', (e) => mouseup(e, el, _data))
  overlay.addEventListener('mousedown', (e) => mousedown(e, el, _data))
  overlay.addEventListener('mousemove', (e) => mousemove(e, el, _data))
  document.body.appendChild(overlay)

  return overlay
}

function checkIfIdInPath(id, path) {
  for (let i = 0; i < path.length; i++) {
    if (path[i].id === id) {
      return true
    }
  }
  return false
}

function adjustElementZIndex(el, index) {
  el.style.zIndex = index
}

function mousedown (e, el, _data) {
  // if the user set a argument to v-drag,
  // it means they only want a specific area to be draggable
  // eg: `v-drag:drag-header` means only the element with 
  // id="drag-header" should be draggable.
  // If the user clicked another area, do nothing.
  if (_data.draggableElementId && !checkIfIdInPath(_data.draggableElementId, e.path)) {
    return
  }

  if (_data.overlay) {
    _data.overlay.remove()
  }
  // set the width each click
  // just in case it changed since last time (by external plugin, for example)
  _data.width = el.offsetWidth
  _data.height = el.offsetHeight
  _data.down = true
  _data.initialX = e.clientX
  _data.initialY = e.clientY
  const overlay = createOverlay(e, el, _data)
  _data.overlay = overlay
  adjustElementZIndex(el, 10001)
}

function mouseup (e, el, _data) {
  _data.down = false
  if (!_data.overlay) {
    return
  }

  _data.overlay.removeEventListener('mouseup', mouseup)
  _data.overlay.removeEventListener('mousedown', mousedown)
  _data.overlay.removeEventListener('mousemove', mousemove)
  _data.overlay.remove()
  adjustElementZIndex(el, _data.initialZIndex)

  setDraggerOffset(el, _data)
}

function reachedLeft(el, _data, movingLeft) {
  return (el.offsetLeft + _data.width >= window.innerWidth) && !movingLeft
}

function reachedRight(el, _data, movingRight) {
  return el.offsetLeft <= 0 && !movingRight
}

function reachedTop(el, _data, movingUp) {
  return el.offsetTop <= 0 && !movingUp 
}

function reachedBottom(el, _data, movingDown) {
  return ((el.offsetTop + _data.height) >= window.innerHeight) && !movingDown
}

function mousemove (e, el, _data) {
  if (_data.down) {
    const movingLeft = _data.cursorPreviousX > e.clientX
    const movingRight = _data.cursorPreviousX < e.clientX
    const movingUp = _data.cursorPreviousY < e.clientY
    const movingDown = _data.cursorPreviousY > e.clientY

    if (_data.constraintToWindow && (reachedLeft(el, _data, movingLeft) || reachedRight(el, _data, movingRight))) {
      // do now allow moving outside the window horizontally
    } else {
      el.style.left = _data.draggerOffsetLeft + (e.clientX - _data.initialX) + 'px'
    }
    if (_data.constraintToWindow && (reachedTop(el, _data, movingUp) || reachedBottom(el, _data, movingDown))) {
      // do now allow moving outside the window vertically
    } else {
      el.style.top = _data.draggerOffsetTop + (e.clientY - _data.initialY) + 'px'
    }
  }
  _data.cursorPreviousX = e.clientX
  _data.cursorPreviousY = e.clientY
}

function setDraggerOffset (el, _data) {
  _data.draggerOffsetLeft = el.offsetLeft
  _data.draggerOffsetTop = el.offsetTop
}

Vue.directive('drag', {
  inserted: function (el, binding, vnode) {
    _data.draggableElementId = binding.arg || null
    _data.constraintToWindow = binding.modifiers['window-only']
    el.addEventListener('mouseup', (e) => mouseup(e, el, _data))
    el.addEventListener('mousedown', (e) => mousedown(e, el, _data))
    el.addEventListener('mousemove', (e) => mousemove(e, el, _data))
    setDraggerOffset(el, _data)
    _data.initialZIndex = el.style.zIndex
  }
});





  Vue.component('flowchart', { 
    template: '<div>flowchart</div>' 
  });

  Vue.component('flowchart-editor', { 
    template: '<div>flowchart-editor</div>' 
  });

  Vue.component('node', { 
    template: '<div class="block" v-drag> node </div>' 
  });

  Vue.component('edge', { 
    template: '<div>edge</div>' 
  });

  new Vue({
    el: '#app',
    data: {
      model: {
        "elements":[ { "id":"n1", "type": "terminal", "text": "value>0", "x": 75 , "y":50, "width": 70, "height": 40 } ]/*,
            "edges":[
                { "id":"e1", "text": "Yes", "elements": ["n1", "n2"] },
                { "id":"e2", "text": "No", "elements": ["n1", "n3"]  },
            ]*/
        }
    }, 
    methods:{
      click(){
        console.log(JSON.stringify(this.model))
      }
    }
  });
</script>